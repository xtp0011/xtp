<!DOCTYPE html>
<html>
	<head>
		<title>Binary Tree</title>
	</head>
	<body>
		<script type="text/javascript">
			/**
			 * 二叉树对象
			 */
			function BinaryTree(){
				
				var root = null;//定义根结点
				
				/**
				 * 构造节点对象
				 * @param {Object} key
				 */
				var Node = function(key){
					this.key = key;
					this.left = null;
					this.right = null;
				}
				
				/**
				 * 插入子节点
				 * @param {Object} node 旧节点
				 * @param {Object} newNode 新节点
				 */
				var insertNode = function(node,newNode){
					if(newNode.key<node.key){
						if(node.left === null){
							node.left = newNode;
						}else{
							insertNode(node.left,newNode);
						}
					}else{
						if(node.right===null){
							node.right = newNode;
						}else{
							insertNode(node.right,newNode);
						}
					}
				}
				
				/**
				 * 插入根节点
				 */
				this.insert = function(key){
					var newNode = new Node(key);
					if(root===null){
						root = newNode;
					}else{
						insertNode(root,newNode);
					}
				}
				
				/**
				 * 中序遍历
				 * @param {Object} node
				 * @param {Object} callback
				 */
				var inOrderTraverseNode = function(node,callback){
					if(node!==null){
						inOrderTraverseNode(node.left,callback);
						callback(node.key);
						inOrderTraverseNode(node.right,callback);
					}
				}
				this.inOrderTraverse = function(callback){
					inOrderTraverseNode(root,callback);
				}
				
				/**
				 * 前序遍历
				 * @param {Object} node
				 * @param {Object} callback
				 */
				var preOrderTraverseNode = function(node,callback){
					if(node!==null){
						callback(node.key);
						preOrderTraverseNode(node.left,callback);
						preOrderTraverseNode(node.right,callback);
					}
				}
				
				this.preOrderTraverse = function(callback){
					preOrderTraverseNode(root,callback);
				}
				
				/**
				 * 后续遍历
				 * @param {Object} node
				 * @param {Object} callbaack
				 */
				var postOrderTraverseNode = function(node,callbaack){
					if(node!==null){
						postOrderTraverseNode(node.left,callbaack);
						postOrderTraverseNode(node.right,callbaack);
						callbaack(node.key);
					}
				}
				
				this.postOrderTraverse = function(callbaack){
					postOrderTraverseNode(root,callbaack);
				}
				
				/**
				 * 查找最小值
				 * @param {Object} node
				 */
				var minNode = function(node){
					if(node){
						while(node && node.left!==null){
							node = node.left;
						}
						return node.key;
					}
					return null;
				}
				
				this.min = function(){
					return minNode(root);
				}
				
				/**
				 * 查找最大值
				 * @param {Object} node
				 */
				var maxNode = function(node){
					if(node){
						while(node && node.right!==null){
							node = node.right;
						}
						return node.key;
					}
					return null;
				}
				
				this.max = function(){
					return maxNode(root);
				}
				
				/**
				 * 根据key值在二叉树查找是否存在
				 * @param {Object} node
				 * @param {Object} key
				 */
				var searchNode = function(node,key){
					if(node===null){
						return false;
					}
					if(key<node.key){
						return searchNode(node.left,key);
					}else if(key>node.key){
						return searchNode(node.right,key);
					}else{
						return true;
					}
				}
				this.search = function(key){
					return searchNode(root,key);
				}
				
				/**
				 * 返回最小节点
				 * @param {Object} node
				 */
				var findMinNode = function(node){
					if(node){
						while(node&&node.left!==null){
							node = node.left;
						}
						return node;
					}
					return null;
				}
				
				/**
				 * 根据key值删除节点
				 * @param {Object} node
				 * @param {Object} key
				 */
				var removeNode = function(node,key){
					if(node===null){
						return null;
					}
					if(key<node.key){
						node.left = removeNode(node.left,key);
						return node;
					}else if(key>node.key){
						node.right = removeNode(node.right,key);
						return node;
					}else{
						if(node.left===null&&node.right===null){
							node = null;
							return node;
						}
						if(node.left===null){
							node = node.right;
							return node
						}else if(node.right===null){
							node = node.left;
							return node;
						}
						var aux = findMinNode(node.right);
						node.key = aux.key;
						node.right = removeNode(node.right,aux.key);
						return node;
					}
				}
				
				this.remove = function(key){
					root = removeNode(root,key);
				}
				
			}	
			
			//测试二叉树对象
			
			var nodes = [8,3,10,1,6,14,4,7,13];
			var binaryTree = new BinaryTree();
			nodes.forEach(function(key){
				binaryTree.insert(key);
			});
			
			var callback = function(key){
				console.log(key);
			}
			
			
			//binaryTree.preOrderTraverse(callback);
			//binaryTree.postOrderTraverse(callback);
			//console.log(binaryTree.min());
			//console.log(binaryTree.max());
			//console.log(binaryTree.search(1));
			binaryTree.remove(4);
			binaryTree.inOrderTraverse(callback);
			
			
		</script>
	</body>
</html>
